/**
<<<<<<< HEAD
 * @fileoverview The CodePathSegment class.
=======
 * @fileoverview A class of the code path segment.
>>>>>>> 421bc8df ( Fix: configuration files)
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const debug = require("./debug-helpers");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given segment is reachable.
 * @param {CodePathSegment} segment A segment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
    return segment.reachable;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A code path segment.
<<<<<<< HEAD
 *
 * Each segment is arranged in a series of linked lists (implemented by arrays)
 * that keep track of the previous and next segments in a code path. In this way,
 * you can navigate between all segments in any code path so long as you have a
 * reference to any segment in that code path.
 *
 * When first created, the segment is in a detached state, meaning that it knows the
 * segments that came before it but those segments don't know that this new segment
 * follows it. Only when `CodePathSegment#markUsed()` is called on a segment does it
 * officially become part of the code path by updating the previous segments to know
 * that this new segment follows.
 */
class CodePathSegment {

    /**
     * Creates a new instance.
=======
 */
class CodePathSegment {

    // eslint-disable-next-line jsdoc/require-description
    /**
>>>>>>> 421bc8df ( Fix: configuration files)
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     *   This array includes unreachable segments.
     * @param {boolean} reachable A flag which shows this is reachable.
     */
    constructor(id, allPrevSegments, reachable) {

        /**
         * The identifier of this code path.
         * Rules use it to store additional information of each rule.
         * @type {string}
         */
        this.id = id;

        /**
<<<<<<< HEAD
         * An array of the next reachable segments.
=======
         * An array of the next segments.
>>>>>>> 421bc8df ( Fix: configuration files)
         * @type {CodePathSegment[]}
         */
        this.nextSegments = [];

        /**
<<<<<<< HEAD
         * An array of the previous reachable segments.
=======
         * An array of the previous segments.
>>>>>>> 421bc8df ( Fix: configuration files)
         * @type {CodePathSegment[]}
         */
        this.prevSegments = allPrevSegments.filter(isReachable);

        /**
<<<<<<< HEAD
         * An array of all next segments including reachable and unreachable.
=======
         * An array of the next segments.
         * This array includes unreachable segments.
>>>>>>> 421bc8df ( Fix: configuration files)
         * @type {CodePathSegment[]}
         */
        this.allNextSegments = [];

        /**
<<<<<<< HEAD
         * An array of all previous segments including reachable and unreachable.
=======
         * An array of the previous segments.
         * This array includes unreachable segments.
>>>>>>> 421bc8df ( Fix: configuration files)
         * @type {CodePathSegment[]}
         */
        this.allPrevSegments = allPrevSegments;

        /**
         * A flag which shows this is reachable.
         * @type {boolean}
         */
        this.reachable = reachable;

        // Internal data.
        Object.defineProperty(this, "internal", {
            value: {
<<<<<<< HEAD

                // determines if the segment has been attached to the code path
                used: false,

                // array of previous segments coming from the end of a loop
=======
                used: false,
>>>>>>> 421bc8df ( Fix: configuration files)
                loopedPrevSegments: []
            }
        });

<<<<<<< HEAD
        /* c8 ignore start */
        if (debug.enabled) {
            this.internal.nodes = [];
        }/* c8 ignore stop */
=======
        /* istanbul ignore if */
        if (debug.enabled) {
            this.internal.nodes = [];
            this.internal.exitNodes = [];
        }
>>>>>>> 421bc8df ( Fix: configuration files)
    }

    /**
     * Checks a given previous segment is coming from the end of a loop.
     * @param {CodePathSegment} segment A previous segment to check.
     * @returns {boolean} `true` if the segment is coming from the end of a loop.
     */
    isLoopedPrevSegment(segment) {
<<<<<<< HEAD
        return this.internal.loopedPrevSegments.includes(segment);
=======
        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
>>>>>>> 421bc8df ( Fix: configuration files)
    }

    /**
     * Creates the root segment.
     * @param {string} id An identifier.
     * @returns {CodePathSegment} The created segment.
     */
    static newRoot(id) {
        return new CodePathSegment(id, [], true);
    }

    /**
<<<<<<< HEAD
     * Creates a new segment and appends it after the given segments.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments
     *      to append to.
=======
     * Creates a segment that follows given segments.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
>>>>>>> 421bc8df ( Fix: configuration files)
     * @returns {CodePathSegment} The created segment.
     */
    static newNext(id, allPrevSegments) {
        return new CodePathSegment(
            id,
            CodePathSegment.flattenUnusedSegments(allPrevSegments),
            allPrevSegments.some(isReachable)
        );
    }

    /**
<<<<<<< HEAD
     * Creates an unreachable segment and appends it after the given segments.
=======
     * Creates an unreachable segment that follows given segments.
>>>>>>> 421bc8df ( Fix: configuration files)
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newUnreachable(id, allPrevSegments) {
        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);

        /*
         * In `if (a) return a; foo();` case, the unreachable segment preceded by
<<<<<<< HEAD
         * the return statement is not used but must not be removed.
=======
         * the return statement is not used but must not be remove.
>>>>>>> 421bc8df ( Fix: configuration files)
         */
        CodePathSegment.markUsed(segment);

        return segment;
    }

    /**
     * Creates a segment that follows given segments.
     * This factory method does not connect with `allPrevSegments`.
     * But this inherits `reachable` flag.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newDisconnected(id, allPrevSegments) {
        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
    }

    /**
<<<<<<< HEAD
     * Marks a given segment as used.
=======
     * Makes a given segment being used.
>>>>>>> 421bc8df ( Fix: configuration files)
     *
     * And this function registers the segment into the previous segments as a next.
     * @param {CodePathSegment} segment A segment to mark.
     * @returns {void}
     */
    static markUsed(segment) {
        if (segment.internal.used) {
            return;
        }
        segment.internal.used = true;

        let i;

        if (segment.reachable) {
<<<<<<< HEAD

            /*
             * If the segment is reachable, then it's officially part of the
             * code path. This loops through all previous segments to update
             * their list of next segments. Because the segment is reachable,
             * it's added to both `nextSegments` and `allNextSegments`.
             */
=======
>>>>>>> 421bc8df ( Fix: configuration files)
            for (i = 0; i < segment.allPrevSegments.length; ++i) {
                const prevSegment = segment.allPrevSegments[i];

                prevSegment.allNextSegments.push(segment);
                prevSegment.nextSegments.push(segment);
            }
        } else {
<<<<<<< HEAD

            /*
             * If the segment is not reachable, then it's not officially part of the
             * code path. This loops through all previous segments to update
             * their list of next segments. Because the segment is not reachable,
             * it's added only to `allNextSegments`.
             */
=======
>>>>>>> 421bc8df ( Fix: configuration files)
            for (i = 0; i < segment.allPrevSegments.length; ++i) {
                segment.allPrevSegments[i].allNextSegments.push(segment);
            }
        }
    }

    /**
     * Marks a previous segment as looped.
     * @param {CodePathSegment} segment A segment.
     * @param {CodePathSegment} prevSegment A previous segment to mark.
     * @returns {void}
     */
    static markPrevSegmentAsLooped(segment, prevSegment) {
        segment.internal.loopedPrevSegments.push(prevSegment);
    }

    /**
<<<<<<< HEAD
     * Creates a new array based on an array of segments. If any segment in the
     * array is unused, then it is replaced by all of its previous segments.
     * All used segments are returned as-is without replacement.
     * @param {CodePathSegment[]} segments The array of segments to flatten.
     * @returns {CodePathSegment[]} The flattened array.
     */
    static flattenUnusedSegments(segments) {
        const done = new Set();
=======
     * Replaces unused segments with the previous segments of each unused segment.
     * @param {CodePathSegment[]} segments An array of segments to replace.
     * @returns {CodePathSegment[]} The replaced array.
     */
    static flattenUnusedSegments(segments) {
        const done = Object.create(null);
        const retv = [];
>>>>>>> 421bc8df ( Fix: configuration files)

        for (let i = 0; i < segments.length; ++i) {
            const segment = segments[i];

            // Ignores duplicated.
<<<<<<< HEAD
            if (done.has(segment)) {
=======
            if (done[segment.id]) {
>>>>>>> 421bc8df ( Fix: configuration files)
                continue;
            }

            // Use previous segments if unused.
            if (!segment.internal.used) {
                for (let j = 0; j < segment.allPrevSegments.length; ++j) {
                    const prevSegment = segment.allPrevSegments[j];

<<<<<<< HEAD
                    if (!done.has(prevSegment)) {
                        done.add(prevSegment);
                    }
                }
            } else {
                done.add(segment);
            }
        }

        return [...done];
=======
                    if (!done[prevSegment.id]) {
                        done[prevSegment.id] = true;
                        retv.push(prevSegment);
                    }
                }
            } else {
                done[segment.id] = true;
                retv.push(segment);
            }
        }

        return retv;
>>>>>>> 421bc8df ( Fix: configuration files)
    }
}

module.exports = CodePathSegment;
