/**
 * @fileoverview Look for useless escapes in strings and regexes
 * @author Onur Temizkan
 */

"use strict";

const astUtils = require("./utils/ast-utils");
<<<<<<< HEAD

=======
<<<<<<< HEAD
const { RegExpParser, visitRegExpAST } = require("@eslint-community/regexpp");

/**
 * @typedef {import('@eslint-community/regexpp').AST.CharacterClass} CharacterClass
 * @typedef {import('@eslint-community/regexpp').AST.ExpressionCharacterClass} ExpressionCharacterClass
 */
=======

>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Returns the union of two sets.
 * @param {Set} setA The first set
 * @param {Set} setB The second set
 * @returns {Set} The union of the two sets
 */
function union(setA, setB) {
    return new Set(function *() {
        yield* setA;
        yield* setB;
    }());
}

const VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
const REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()Bk"));

<<<<<<< HEAD
=======
<<<<<<< HEAD
/*
 * Set of characters that require escaping in character classes in `unicodeSets` mode.
 * ( ) [ ] { } / - \ | are ClassSetSyntaxCharacter
 */
const REGEX_CLASSSET_CHARACTER_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("q/[{}|()-"));

/*
 * A single character set of ClassSetReservedDoublePunctuator.
 * && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~ are ClassSetReservedDoublePunctuator
 */
const REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR = new Set("!#$%&*+,.:;<=>?@^`~");

/** @type {import('../shared/types').Rule} */
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
/**
 * Parses a regular expression into a list of characters with character class info.
 * @param {string} regExpText The raw text used to create the regular expression
 * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.
 * @example
 *
 * parseRegExp('a\\b[cd-]')
 *
 * returns:
 * [
 *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},
 *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},
 *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},
 *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},
 *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}
 * ]
 */
function parseRegExp(regExpText) {
    const charList = [];

    regExpText.split("").reduce((state, char, index) => {
        if (!state.escapeNextChar) {
            if (char === "\\") {
                return Object.assign(state, { escapeNextChar: true });
            }
            if (char === "[" && !state.inCharClass) {
                return Object.assign(state, { inCharClass: true, startingCharClass: true });
            }
            if (char === "]" && state.inCharClass) {
                if (charList.length && charList[charList.length - 1].inCharClass) {
                    charList[charList.length - 1].endsCharClass = true;
                }
                return Object.assign(state, { inCharClass: false, startingCharClass: false });
            }
        }
        charList.push({
            text: char,
            index,
            escaped: state.escapeNextChar,
            inCharClass: state.inCharClass,
            startsCharClass: state.startingCharClass,
            endsCharClass: false
        });
        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });
    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });

    return charList;
}

<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
=======
<<<<<<< HEAD
            description: "Disallow unnecessary escape characters",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-useless-escape"
        },

        hasSuggestions: true,

        messages: {
            unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
            removeEscape: "Remove the `\\`. This maintains the current functionality.",
            removeEscapeDoNotKeepSemantics: "Remove the `\\` if it was inserted by mistake.",
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
            description: "disallow unnecessary escape characters",
            category: "Best Practices",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-useless-escape",
            suggestion: true
        },

        messages: {
            unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
            removeEscape: "Remove the `\\`. This maintains the current functionality.",
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
            escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
        },

        schema: []
    },

    create(context) {
<<<<<<< HEAD
        const sourceCode = context.getSourceCode();
=======
<<<<<<< HEAD
        const sourceCode = context.sourceCode;
        const parser = new RegExpParser();
=======
        const sourceCode = context.getSourceCode();
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0

        /**
         * Reports a node
         * @param {ASTNode} node The node to report
         * @param {number} startOffset The backslash's offset from the start of the node
         * @param {string} character The uselessly escaped character (not including the backslash)
<<<<<<< HEAD
=======
<<<<<<< HEAD
         * @param {boolean} [disableEscapeBackslashSuggest] `true` if escapeBackslash suggestion should be turned off.
         * @returns {void}
         */
        function report(node, startOffset, character, disableEscapeBackslashSuggest) {
            const rangeStart = node.range[0] + startOffset;
            const range = [rangeStart, rangeStart + 1];
            const start = sourceCode.getLocFromIndex(rangeStart);
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * @returns {void}
         */
        function report(node, startOffset, character) {
            const start = sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset);
            const rangeStart = sourceCode.getIndexFromLoc(node.loc.start) + startOffset;
            const range = [rangeStart, rangeStart + 1];
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0

            context.report({
                node,
                loc: {
                    start,
                    end: { line: start.line, column: start.column + 1 }
                },
                messageId: "unnecessaryEscape",
                data: { character },
                suggest: [
                    {
<<<<<<< HEAD
                        messageId: "removeEscape",
=======
<<<<<<< HEAD

                        // Removing unnecessary `\` characters in a directive is not guaranteed to maintain functionality.
                        messageId: astUtils.isDirective(node.parent)
                            ? "removeEscapeDoNotKeepSemantics" : "removeEscape",
=======
                        messageId: "removeEscape",
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                        fix(fixer) {
                            return fixer.removeRange(range);
                        }
                    },
<<<<<<< HEAD
=======
<<<<<<< HEAD
                    ...disableEscapeBackslashSuggest
                        ? []
                        : [
                            {
                                messageId: "escapeBackslash",
                                fix(fixer) {
                                    return fixer.insertTextBeforeRange(range, "\\");
                                }
                            }
                        ]
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                    {
                        messageId: "escapeBackslash",
                        fix(fixer) {
                            return fixer.insertTextBeforeRange(range, "\\");
                        }
                    }
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                ]
            });
        }

        /**
         * Checks if the escape character in given string slice is unnecessary.
         * @private
         * @param {ASTNode} node node to validate.
         * @param {string} match string slice to validate.
         * @returns {void}
         */
        function validateString(node, match) {
            const isTemplateElement = node.type === "TemplateElement";
            const escapedChar = match[0][1];
            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
            let isQuoteEscape;

            if (isTemplateElement) {
                isQuoteEscape = escapedChar === "`";

                if (escapedChar === "$") {

                    // Warn if `\$` is not followed by `{`
                    isUnnecessaryEscape = match.input[match.index + 2] !== "{";
                } else if (escapedChar === "{") {

                    /*
                     * Warn if `\{` is not preceded by `$`. If preceded by `$`, escaping
                     * is necessary and the rule should not warn. If preceded by `/$`, the rule
                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.
                     */
                    isUnnecessaryEscape = match.input[match.index - 1] !== "$";
                }
            } else {
                isQuoteEscape = escapedChar === node.raw[0];
            }

            if (isUnnecessaryEscape && !isQuoteEscape) {
<<<<<<< HEAD
                report(node, match.index + 1, match[0].slice(1));
=======
<<<<<<< HEAD
                report(node, match.index, match[0].slice(1));
=======
                report(node, match.index + 1, match[0].slice(1));
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
            }
        }

        /**
<<<<<<< HEAD
=======
<<<<<<< HEAD
         * Checks if the escape character in given regexp is unnecessary.
         * @private
         * @param {ASTNode} node node to validate.
         * @returns {void}
         */
        function validateRegExp(node) {
            const { pattern, flags } = node.regex;
            let patternNode;
            const unicode = flags.includes("u");
            const unicodeSets = flags.includes("v");

            try {
                patternNode = parser.parsePattern(pattern, 0, pattern.length, { unicode, unicodeSets });
            } catch {

                // Ignore regular expressions with syntax errors
                return;
            }

            /** @type {(CharacterClass | ExpressionCharacterClass)[]} */
            const characterClassStack = [];

            visitRegExpAST(patternNode, {
                onCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),
                onCharacterClassLeave: () => characterClassStack.shift(),
                onExpressionCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),
                onExpressionCharacterClassLeave: () => characterClassStack.shift(),
                onCharacterEnter(characterNode) {
                    if (!characterNode.raw.startsWith("\\")) {

                        // It's not an escaped character.
                        return;
                    }

                    const escapedChar = characterNode.raw.slice(1);

                    if (escapedChar !== String.fromCodePoint(characterNode.value)) {

                        // It's a valid escape.
                        return;
                    }
                    let allowedEscapes;

                    if (characterClassStack.length) {
                        allowedEscapes = unicodeSets ? REGEX_CLASSSET_CHARACTER_ESCAPES : REGEX_GENERAL_ESCAPES;
                    } else {
                        allowedEscapes = REGEX_NON_CHARCLASS_ESCAPES;
                    }
                    if (allowedEscapes.has(escapedChar)) {
                        return;
                    }

                    const reportedIndex = characterNode.start + 1;
                    let disableEscapeBackslashSuggest = false;

                    if (characterClassStack.length) {
                        const characterClassNode = characterClassStack[0];

                        if (escapedChar === "^") {

                            /*
                             * The '^' character is also a special case; it must always be escaped outside of character classes, but
                             * it only needs to be escaped in character classes if it's at the beginning of the character class. To
                             * account for this, consider it to be a valid escape character outside of character classes, and filter
                             * out '^' characters that appear at the start of a character class.
                             */
                            if (characterClassNode.start + 1 === characterNode.start) {

                                return;
                            }
                        }
                        if (!unicodeSets) {
                            if (escapedChar === "-") {

                                /*
                                 * The '-' character is a special case, because it's only valid to escape it if it's in a character
                                 * class, and is not at either edge of the character class. To account for this, don't consider '-'
                                 * characters to be valid in general, and filter out '-' characters that appear in the middle of a
                                 * character class.
                                 */
                                if (characterClassNode.start + 1 !== characterNode.start && characterNode.end !== characterClassNode.end - 1) {

                                    return;
                                }
                            }
                        } else { // unicodeSets mode
                            if (REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR.has(escapedChar)) {

                                // Escaping is valid if it is a ClassSetReservedDoublePunctuator.
                                if (pattern[characterNode.end] === escapedChar) {
                                    return;
                                }
                                if (pattern[characterNode.start - 1] === escapedChar) {
                                    if (escapedChar !== "^") {
                                        return;
                                    }

                                    // If the previous character is a `negate` caret(`^`), escape to caret is unnecessary.

                                    if (!characterClassNode.negate) {
                                        return;
                                    }
                                    const negateCaretIndex = characterClassNode.start + 1;

                                    if (negateCaretIndex < characterNode.start - 1) {
                                        return;
                                    }
                                }
                            }

                            if (characterNode.parent.type === "ClassIntersection" || characterNode.parent.type === "ClassSubtraction") {
                                disableEscapeBackslashSuggest = true;
                            }
                        }
                    }

                    report(
                        node,
                        reportedIndex,
                        escapedChar,
                        disableEscapeBackslashSuggest
                    );
                }
            });
        }

        /**
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * Checks if a node has an escape.
         * @param {ASTNode} node node to check.
         * @returns {void}
         */
        function check(node) {
            const isTemplateElement = node.type === "TemplateElement";

            if (
                isTemplateElement &&
                node.parent &&
                node.parent.parent &&
                node.parent.parent.type === "TaggedTemplateExpression" &&
                node.parent === node.parent.parent.quasi
            ) {

                // Don't report tagged template literals, because the backslash character is accessible to the tag function.
                return;
            }

            if (typeof node.value === "string" || isTemplateElement) {

                /*
                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.
                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.
                 */
                if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment") {
                    return;
                }

<<<<<<< HEAD
                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
=======
<<<<<<< HEAD
                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;
=======
                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                const pattern = /\\[^\d]/gu;
                let match;

                while ((match = pattern.exec(value))) {
                    validateString(node, match);
                }
            } else if (node.regex) {
<<<<<<< HEAD
=======
<<<<<<< HEAD
                validateRegExp(node);
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                parseRegExp(node.regex.pattern)

                    /*
                     * The '-' character is a special case, because it's only valid to escape it if it's in a character
                     * class, and is not at either edge of the character class. To account for this, don't consider '-'
                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a
                     * character class.
                     */
                    .filter(charInfo => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))

                    /*
                     * The '^' character is also a special case; it must always be escaped outside of character classes, but
                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To
                     * account for this, consider it to be a valid escape character outside of character classes, and filter
                     * out '^' characters that appear at the start of a character class.
                     */
                    .filter(charInfo => !(charInfo.text === "^" && charInfo.startsCharClass))

                    // Filter out characters that aren't escaped.
                    .filter(charInfo => charInfo.escaped)

                    // Filter out characters that are valid to escape, based on their position in the regular expression.
                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))

                    // Report all the remaining characters.
                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
            }

        }

        return {
            Literal: check,
            TemplateElement: check
        };
    }
};
