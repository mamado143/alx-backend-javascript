/**
 * @fileoverview Rule to flag non-quoted property names in object literals.
 * @author Mathias Bynens <http://mathiasbynens.be/>
<<<<<<< HEAD
=======
<<<<<<< HEAD
 * @deprecated in ESLint v8.53.0
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

<<<<<<< HEAD
const espree = require("espree"),
    keywords = require("./utils/keywords");
=======
<<<<<<< HEAD
const espree = require("espree");
const astUtils = require("./utils/ast-utils");
const keywords = require("./utils/keywords");
=======
const espree = require("espree"),
    keywords = require("./utils/keywords");
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
=======
<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",

        docs: {
            description: "Require quotes around object literal property names",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/quote-props"
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "require quotes around object literal property names",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/quote-props"
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
        },

        schema: {
            anyOf: [
                {
                    type: "array",
                    items: [
                        {
                            enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
                        }
                    ],
                    minItems: 0,
                    maxItems: 1
                },
                {
                    type: "array",
                    items: [
                        {
                            enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
                        },
                        {
                            type: "object",
                            properties: {
                                keywords: {
                                    type: "boolean"
                                },
                                unnecessary: {
                                    type: "boolean"
                                },
                                numbers: {
                                    type: "boolean"
                                }
                            },
                            additionalProperties: false
                        }
                    ],
                    minItems: 0,
                    maxItems: 2
                }
            ]
        },

<<<<<<< HEAD
        fixable: "code"
=======
<<<<<<< HEAD
        fixable: "code",
        messages: {
            requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
            inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
            unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
            unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
            unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
            unquotedPropertyFound: "Unquoted property '{{property}}' found.",
            redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
        }
=======
        fixable: "code"
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
    },

    create(context) {

        const MODE = context.options[0],
            KEYWORDS = context.options[1] && context.options[1].keywords,
            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
            NUMBERS = context.options[1] && context.options[1].numbers,

<<<<<<< HEAD
=======
<<<<<<< HEAD
            sourceCode = context.sourceCode;
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
            MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
            MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
            MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
            MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.",
            sourceCode = context.getSourceCode();
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0


        /**
         * Checks whether a certain string constitutes an ES3 token
<<<<<<< HEAD
=======
<<<<<<< HEAD
         * @param {string} tokenStr The string to be checked.
         * @returns {boolean} `true` if it is an ES3 token.
         */
        function isKeyword(tokenStr) {
            return keywords.includes(tokenStr);
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * @param   {string} tokenStr The string to be checked.
         * @returns {boolean} `true` if it is an ES3 token.
         */
        function isKeyword(tokenStr) {
            return keywords.indexOf(tokenStr) >= 0;
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
        }

        /**
         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)
<<<<<<< HEAD
         * @param   {string} rawKey The raw key value from the source
         * @param   {espreeTokens} tokens The espree-tokenized node key
         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked
=======
<<<<<<< HEAD
         * @param {string} rawKey The raw key value from the source
         * @param {espreeTokens} tokens The espree-tokenized node key
         * @param {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked
=======
         * @param   {string} rawKey The raw key value from the source
         * @param   {espreeTokens} tokens The espree-tokenized node key
         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * @returns {boolean} Whether or not a key has redundant quotes.
         * @private
         */
        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&
<<<<<<< HEAD
                (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
=======
<<<<<<< HEAD
                (["Identifier", "Keyword", "Null", "Boolean"].includes(tokens[0].type) ||
=======
                (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                (tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));
        }

        /**
         * Returns a string representation of a property node with quotes removed
         * @param {ASTNode} key Key AST Node, which may or may not be quoted
         * @returns {string} A replacement string for this property
         */
        function getUnquotedKey(key) {
            return key.type === "Identifier" ? key.name : key.value;
        }

        /**
         * Returns a string representation of a property node with quotes added
         * @param {ASTNode} key Key AST Node, which may or may not be quoted
         * @returns {string} A replacement string for this property
         */
        function getQuotedKey(key) {
            if (key.type === "Literal" && typeof key.value === "string") {

                // If the key is already a string literal, don't replace the quotes with double quotes.
                return sourceCode.getText(key);
            }

            // Otherwise, the key is either an identifier or a number literal.
            return `"${key.type === "Identifier" ? key.name : key.value}"`;
        }

        /**
         * Ensures that a property's key is quoted only when necessary
<<<<<<< HEAD
         * @param   {ASTNode} node Property AST node
=======
<<<<<<< HEAD
         * @param {ASTNode} node Property AST node
=======
         * @param   {ASTNode} node Property AST node
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * @returns {void}
         */
        function checkUnnecessaryQuotes(node) {
            const key = node.key;

            if (node.method || node.computed || node.shorthand) {
                return;
            }

            if (key.type === "Literal" && typeof key.value === "string") {
                let tokens;

                try {
                    tokens = espree.tokenize(key.value);
<<<<<<< HEAD
                } catch (e) {
=======
<<<<<<< HEAD
                } catch {
=======
                } catch (e) {
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                    return;
                }

                if (tokens.length !== 1) {
                    return;
                }

                const isKeywordToken = isKeyword(tokens[0].value);

                if (isKeywordToken && KEYWORDS) {
                    return;
                }

                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
                    context.report({
                        node,
<<<<<<< HEAD
                        message: MESSAGE_UNNECESSARY,
=======
<<<<<<< HEAD
                        messageId: "unnecessarilyQuotedProperty",
=======
                        message: MESSAGE_UNNECESSARY,
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                        data: { property: key.value },
                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))
                    });
                }
            } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
                context.report({
                    node,
<<<<<<< HEAD
=======
<<<<<<< HEAD
                    messageId: "unquotedReservedProperty",
                    data: { property: key.name },
                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
                });
            } else if (NUMBERS && key.type === "Literal" && astUtils.isNumericLiteral(key)) {
                context.report({
                    node,
                    messageId: "unquotedNumericProperty",
=======
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                    message: MESSAGE_RESERVED,
                    data: { property: key.name },
                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
                });
            } else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
                context.report({
                    node,
                    message: MESSAGE_NUMERIC,
<<<<<<< HEAD
=======
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                    data: { property: key.value },
                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
                });
            }
        }

        /**
         * Ensures that a property's key is quoted
<<<<<<< HEAD
         * @param   {ASTNode} node Property AST node
=======
<<<<<<< HEAD
         * @param {ASTNode} node Property AST node
=======
         * @param   {ASTNode} node Property AST node
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * @returns {void}
         */
        function checkOmittedQuotes(node) {
            const key = node.key;

            if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
                context.report({
                    node,
<<<<<<< HEAD
                    message: MESSAGE_UNQUOTED,
=======
<<<<<<< HEAD
                    messageId: "unquotedPropertyFound",
=======
                    message: MESSAGE_UNQUOTED,
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                    data: { property: key.name || key.value },
                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
                });
            }
        }

        /**
         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes
<<<<<<< HEAD
         * @param   {ASTNode} node Property AST node
         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
=======
<<<<<<< HEAD
         * @param {ASTNode} node Property AST node
         * @param {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
=======
         * @param   {ASTNode} node Property AST node
         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
         * @returns {void}
         */
        function checkConsistency(node, checkQuotesRedundancy) {
            const quotedProps = [],
                unquotedProps = [];
            let keywordKeyName = null,
                necessaryQuotes = false;

            node.properties.forEach(property => {
                const key = property.key;

                if (!key || property.method || property.computed || property.shorthand) {
                    return;
                }

                if (key.type === "Literal" && typeof key.value === "string") {

                    quotedProps.push(property);

                    if (checkQuotesRedundancy) {
                        let tokens;

                        try {
                            tokens = espree.tokenize(key.value);
<<<<<<< HEAD
                        } catch (e) {
=======
<<<<<<< HEAD
                        } catch {
=======
                        } catch (e) {
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                            necessaryQuotes = true;
                            return;
                        }

                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
                    }
                } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
                    unquotedProps.push(property);
                    necessaryQuotes = true;
                    keywordKeyName = key.name;
                } else {
                    unquotedProps.push(property);
                }
            });

            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
                quotedProps.forEach(property => {
                    context.report({
                        node: property,
<<<<<<< HEAD
                        message: "Properties shouldn't be quoted as all quotes are redundant.",
=======
<<<<<<< HEAD
                        messageId: "redundantQuoting",
=======
                        message: "Properties shouldn't be quoted as all quotes are redundant.",
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))
                    });
                });
            } else if (unquotedProps.length && keywordKeyName) {
                unquotedProps.forEach(property => {
                    context.report({
                        node: property,
<<<<<<< HEAD
                        message: "Properties should be quoted as '{{property}}' is a reserved word.",
=======
<<<<<<< HEAD
                        messageId: "requireQuotesDueToReservedWord",
=======
                        message: "Properties should be quoted as '{{property}}' is a reserved word.",
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                        data: { property: keywordKeyName },
                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
                    });
                });
            } else if (quotedProps.length && unquotedProps.length) {
                unquotedProps.forEach(property => {
                    context.report({
                        node: property,
<<<<<<< HEAD
                        message: "Inconsistently quoted property '{{key}}' found.",
=======
<<<<<<< HEAD
                        messageId: "inconsistentlyQuotedProperty",
=======
                        message: "Inconsistently quoted property '{{key}}' found.",
>>>>>>> 421bc8df ( Fix: configuration files)
>>>>>>> c36f9991e2dbbd453d7a1e0d08a2e99a3685e7b0
                        data: { key: property.key.name || property.key.value },
                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
                    });
                });
            }
        }

        return {
            Property(node) {
                if (MODE === "always" || !MODE) {
                    checkOmittedQuotes(node);
                }
                if (MODE === "as-needed") {
                    checkUnnecessaryQuotes(node);
                }
            },
            ObjectExpression(node) {
                if (MODE === "consistent") {
                    checkConsistency(node, false);
                }
                if (MODE === "consistent-as-needed") {
                    checkConsistency(node, true);
                }
            }
        };

    }
};
